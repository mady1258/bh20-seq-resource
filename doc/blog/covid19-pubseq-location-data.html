<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2021-04-26 Mon 02:25 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>COVID-19 PubSeq Location Data</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Pjotr Prins" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="Blog stylesheet" type="text/css" href="blog.css" />
<script type="text/javascript">
// @license magnet:?xt=urn:btih:e95b018ef3580986a04669f1b5879592219e2a7a&dn=public-domain.txt Public Domain
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
</head>
<body>
<div id="content">
<h1 class="title">COVID-19 PubSeq Location Data</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org5559f32">1. Introduction</a></li>
<li><a href="#org2843661">2. Location data</a>
<ul>
<li><a href="#orgd591aea">2.1. Why use WikiData URIs instead of GPS coordinates?</a></li>
</ul>
</li>
<li><a href="#org73b6c3a">3. Normalizing location data</a>
<ul>
<li><a href="#org9452b70">3.1. Simple search Wikidata</a>
<ul>
<li><a href="#org90e875d">3.1.1. Fetch all 180 odd countries with aliases</a></li>
<li><a href="#orgb755685">3.1.2. Fetch all places with coordinates (no aliases)</a></li>
<li><a href="#orgf569871">3.1.3. Fetch all states</a></li>
</ul>
</li>
<li><a href="#org1db088a">3.2. Start normalizing geo-location</a>
<ul>
<li><a href="#orgc02c096">3.2.1. Normalize by country</a></li>
<li><a href="#org35cadc3">3.2.2. Normalize by state</a></li>
<li><a href="#org1c142a5">3.2.3. Refine location</a></li>
</ul>
</li>
<li><a href="#org56a5937">3.3. RegEx search known items</a></li>
<li><a href="#org8f974fe">3.4. Fuzzy search Wikidata</a></li>
</ul>
</li>
<li><a href="#org1dd9aaa">4. Shape expressions (ShEx) and validation</a></li>
<li><a href="#org99d0c7e">5. Missing data</a></li>
</ul>
</div>
</div>

<div id="outline-container-org5559f32" class="outline-2">
<h2 id="org5559f32"><span class="section-number-2">1</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
<p>
Normalized location metadata is one of the most valuable features of
PubSeq. In this document we explain how we create that metadata and
why it is not so easy!
</p>
</div>
</div>

<div id="outline-container-org2843661" class="outline-2">
<h2 id="org2843661"><span class="section-number-2">2</span> Location data</h2>
<div class="outline-text-2" id="text-2">
<p>
When data gets uploaded to central repositories some metadata needs to
be provided about sampling location and uploader (lab) location. This
should be straightforward. Yeah, right.
</p>

<p>
The main problem, probably, is that central repositories can not be
strict about these parameters - otherwise uploads fail and uploaders
get annoyed (and may stop uploading). This basic problem is about
human expectation.
</p>

<p>
The other problem is that not everything is fixed to a site. What to
to make of the location `USA: Cruise_Ship_1, California' in <a href="https://www.ncbi.nlm.nih.gov/nuccore/MT810507">MT810507</a>.
From the full record we best place the sample on San Diego.
</p>

<p>
There exist many opportunities for ambiguous entries, such as Memphis
TN and Memphis IN. We decided to settle for Wikidata URIs because (1)
they are unambiguous and (2) allow for fetching more information, such
as population size, density, county, country, and GPS
coordinates. Click on the wikidata entries for <a href="http://www.wikidata.org/entity/Q16563">Memphis Tennessee</a> (not
the song <a href="https://www.wikidata.org/wiki/Q2447864">Memphis Tennessee</a>), <a href="https://www.wikidata.org/wiki/Q2699142">Memphis Indiana</a>, <a href="https://www.wikidata.org/wiki/Q979971">Memphis Texas</a> <a href="https://www.wikidata.org/wiki/Q1890251">Memphis
Michigan</a> and <a href="https://www.wikidata.org/wiki/Q3289795">Memphis Nebraska</a>. And then there is the original <a href="https://www.wikidata.org/wiki/Q5715">Memphis
Egypt</a>, ancient capital of Aneb-Hetch. All listed on Wikidata. Wikidata
URIs are great at disambiguation of locality while grouping data in a
sensible way for research!
</p>
</div>

<div id="outline-container-orgd591aea" class="outline-3">
<h3 id="orgd591aea"><span class="section-number-3">2.1</span> Why use WikiData URIs instead of GPS coordinates?</h3>
<div class="outline-text-3" id="text-2-1">
<p>
A wikidata URI gives access to a lot of extra information that can be
queried about an entry. It is fairly straightforward, for example, to
find all entries that relate to one county or country. And these are
typical queries for researchers. Wikidata URIs allows fetching GPS
coordinates - we do that to display samples on the map. For example
</p>

<div class="org-src-container">
<pre class="src src-sql"><span style="color: #fff59d;">select</span> ?gps  <span style="color: #fff59d;">where</span> {
  <a href="http://www.wikidata.org/entity/Q16563">&lt;http://www.wikidata.org/entity/Q16563&gt;</a> wdt:P625 ?gps .
}
</pre>
</div>
<p>
<a href="https://query.wikidata.org/#select%20%3Fgps%20%20where%20%7B%0A%20%20%3Chttp%3A%2F%2Fwww.wikidata.org%2Fentity%2FQ16563%3E%20wdt%3AP625%20%3Fgps%20.%0A%7D">execute query</a>
</p>

<p>
returns
</p>

<pre class="example">
Point(-89.971111111 35.1175)
</pre>


<p>
To get a list of all directly available items related to Memphis TN:
</p>

<div class="org-src-container">
<pre class="src src-sql"><span style="color: #fff59d;">select</span> ?p ?s  <span style="color: #fff59d;">where</span> {
  <a href="http://www.wikidata.org/entity/Q16563">&lt;http://www.wikidata.org/entity/Q16563&gt;</a> ?p ?s .
}
</pre>
</div>
<p>
[<a href="https://query.wikidata.org/#select%20%3Fp%20%3Fgps%20where%20%7B%0A%3Chttp%3A%2F%2Fwww.wikidata.org%2Fentity%2FQ2447864%3E%20%3Fp%20%3Fgps%20.%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D">execute query</a>]
</p>

<p>
The other way round, querying samples and getting relevant information
directly from GPS coordinates, is much harder. Wikidata URIs are very
useful.
</p>
</div>
</div>
</div>

<div id="outline-container-org73b6c3a" class="outline-2">
<h2 id="org73b6c3a"><span class="section-number-2">3</span> Normalizing location data</h2>
<div class="outline-text-2" id="text-3">
<p>
Wikidata is the stable and trusted backend for Wikipedia, a massive
online encyclopedia. It is also one of largest RDF-based databases on the
planet and won't disappear any time soon. Wikidata contains URIs for
almost all geographical entities of interest. Wikidata is therefore a
good choice for normalizing geographical location data.
</p>

<p>
PubSeq gets data from different sources and needs to convert that
information to Wikidata URIs. So, how would we go about fixing the
location `USA: Cruise_Ship_1, California' in <a href="https://www.ncbi.nlm.nih.gov/nuccore/MT810507">MT810507</a>. We can tokenize
the address information into `USA' and `California'. Also `San Diego'
is listed as an address in the record. We should aim for the smallest
Geo description `San Diego' and relate that back to Wikidata to find
the URI. Now Wikidata won't be pleased if we hit it with 100 thousand
queries, so best is to fetch location related info and turn that into
a small database using Python Pandas, or similar.
</p>

<p>
We do not want to find all these links by hand. Initially, when we started out,
we did just that. But at 100K entries it is not feasible. So we end up
with a stepped approach:
</p>

<ol class="org-ol">
<li>Search a database with all known Wikidata entries</li>
<li>Search a separate database with 'vetted' items including Regex</li>
<li>If GPS coordinates are provided we can use them for location</li>
<li>Tokenize the record and use the Wikidata or Wikipedia search engine</li>
</ol>

<p>
Hopefully that covers over 90% of cases correctly.  We still may end
up with misses and wrong data. E.g. it is easy to imagine a sample
taken on Antartica that got sequenced in the USA and gets placed in
the USA. In Wiki-spirit the best solution is to leave it to end-users
to re-place those entries. End-users scale, unlike us. For this we
will create a simple API.
</p>

<p>
Note that normalization has to be fully automated to execute regular
updates from the upstream data repositories. There is no way we can
annotate these by hand ourselves.
</p>

<p>
Also data fetched from wikidata is not stored in the github
repository, but online on IPFS.
</p>
</div>

<div id="outline-container-org9452b70" class="outline-3">
<h3 id="org9452b70"><span class="section-number-3">3.1</span> Simple search Wikidata</h3>
<div class="outline-text-3" id="text-3-1">
<p>
We can dump all known contries/states/states/cities from Wikidata into
files.
</p>
</div>

<div id="outline-container-org90e875d" class="outline-4">
<h4 id="org90e875d"><span class="section-number-4">3.1.1</span> Fetch all 180 odd countries with aliases</h4>
<div class="outline-text-4" id="text-3-1-1">
<div class="org-src-container">
<pre class="src src-sql"><span style="color: #fff59d;">SELECT</span> <span style="color: #fff59d;">DISTINCT</span> * <span style="color: #fff59d;">WHERE</span> {
  ?place wdt:P17 ?country .
  ?place (a|wdt:P31|wdt:P279) wd:Q6256 .
  minus { ?place wdt:P31 wd:Q3024240 } .
  ?country rdfs:label ?countryname .
  FILTER( LANG(?countryname)="en") .
  OPTIONAL {
      ?country wdt:P30 ?continent.
      ?continent rdfs:label ?continent_label
      FILTER (lang(?continent_label)=<span style="color: #9ccc65;">'en'</span>)
    }
  }
</pre>
</div>

<p>
<a href="https://query.wikidata.org/#%0A%20%20SELECT%20DISTINCT%20%2a%20WHERE%20%7B%0A%20%20%20%20%3Fplace%20wdt%3AP17%20%3Fcountry%20.%0A%20%20%20%20%3Fplace%20%28a%7Cwdt%3AP31%7Cwdt%3AP279%29%20wd%3AQ6256%20.%0A%20%20%20%20minus%20%7B%20%3Fplace%20wdt%3AP31%20wd%3AQ3024240%20%7D%20.%0A%20%20%20%20%3Fcountry%20rdfs%3Alabel%20%3Fcountryname%20.%0A%20%20%20%20FILTER%28%20LANG%28%3Fcountryname%29%3D%22en%22%29%20.%0A%20%20%20%20OPTIONAL%20%7B%0A%20%20%20%20%20%20%20%20%3Fcountry%20wdt%3AP30%20%3Fcontinent.%0A%20%20%20%20%20%20%20%20%3Fcontinent%20rdfs%3Alabel%20%3Fcontinent_label%0A%20%20%20%20%20%20%20%20FILTER%20%28lang%28%3Fcontinent_label%29%3D%27en%27%29%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A">run query</a>
</p>

<p>
Save the file as data/countries.tsv.
</p>

<p>
Just adding <code>?place skos:altLabel ?alias</code> for all country aliases
gets 15K results:
</p>

<div class="org-src-container">
<pre class="src src-sql"><span style="color: #fff59d;">SELECT</span> <span style="color: #fff59d;">DISTINCT</span> * <span style="color: #fff59d;">WHERE</span> {
  ?place wdt:P17 ?country ;
    (a|wdt:P31|wdt:P279) wd:Q6256 .
  minus { ?place wdt:P31 wd:Q3024240 } .
  ?place skos:altLabel ?<span style="color: #fff59d;">alias</span> .
}
</pre>
</div>

<p>
<a href="https://query.wikidata.org/#%20%20SELECT%20DISTINCT%20%2a%20WHERE%20%7B%0A%20%20%20%20%3Fplace%20wdt%3AP17%20%3Fcountry%20%3B%0A%20%20%20%20%20%20%28a%7Cwdt%3AP31%7Cwdt%3AP279%29%20wd%3AQ6256%20.%0A%20%20%20%20minus%20%7B%20%3Fplace%20wdt%3AP31%20wd%3AQ3024240%20%7D%20.%0A%20%20%20%20%3Fplace%20skos%3AaltLabel%20%3Falias%20.%0A%20%20%7D">run query</a>
</p>

<p>
Save the file as data/wikidata/country_aliases.tsv.
</p>
</div>
</div>

<div id="outline-container-orgb755685" class="outline-4">
<h4 id="orgb755685"><span class="section-number-4">3.1.2</span> Fetch all places with coordinates (no aliases)</h4>
<div class="outline-text-4" id="text-3-1-2">
<div class="org-src-container">
<pre class="src src-sql"><span style="color: #fff59d;">select</span> <span style="color: #fff59d;">DISTINCT</span> * <span style="color: #fff59d;">where</span> {
  ?place wdt:P17 ?country ;
         wdt:P625 ?coor ;
         wdt:P1082 ?population .
}
</pre>
</div>

<p>
518076 results in 20247 ms
</p>

<div class="org-src-container">
<pre class="src src-sql"><span style="color: #fff59d;">select</span> <span style="color: #fff59d;">DISTINCT</span> * <span style="color: #fff59d;">where</span> {
  ?place wdt:P17 ?country ;
       wdt:P625 ?coor ;
       wdt:P1082 ?population ;
       rdfs:label ?placename .
}
</pre>
</div>

<p>
<a href="https://query.wikidata.org/#select%20%2a%20where%20%7B%0A%20%20%3Fplace%20wdt%3AP625%20%3Fcoor%20%3B%0A%20%20%20%20%20%20%20%20%20wdt%3AP17%20%3Fcountry%20.%0A%20%20minus%20%7B%20%3Fplace%20wdt%3AP31%20wd%3AQ3024240%20%7D%20.%0A%20%20%3Fplace%20wdt%3AP1082%20%3Fpopulation%20.%20%20%0A%7D%0A%0A">run query</a> &#x2014; 520255 results in 32151 ms
</p>

<p>
I ended up chunking the query using OFFSET in the script wikidata-fetch-places.rb
</p>

<div class="org-src-container">
<pre class="src src-sql"><span style="color: #fff59d;">select</span> <span style="color: #fff59d;">DISTINCT</span> ?place ?placename ?country ?coor ?population <span style="color: #fff59d;">where</span> {
  ?place wdt:P17 ?country ;
         wdt:P625 ?coor ;
         wdt:P1082 ?population .
  FILTER (?population &gt; 9999)
  # ?place rdfs:label ?placename .
  # FILTER (lang(?placename)=<span style="color: #9ccc65;">'en'</span>)
  ?place rdfs:label ?placename filter (lang(?placename) = "en").
} <span style="color: #fff59d;">limit</span> 10000
</pre>
</div>

<p>
<a href="https://query.wikidata.org/#select%20DISTINCT%20%3Fplace%20%3Fplacename%20%3Fcountry%20%3Fcoor%20%3Fpopulation%20where%20%7B%0A%20%20%3Fplace%20wdt%3AP17%20%3Fcountry%20%3B%0A%20%20%20%20%20%20%20%20%20wdt%3AP625%20%3Fcoor%20%3B%0A%20%20%20%20%20%20%20%20%20wdt%3AP1082%20%3Fpopulation%20.%0A%20%20FILTER%20%28%3Fpopulation%20%3E%209999%29%0A%20%20%3Fplace%20rdfs%3Alabel%20%3Fplacename%20.%20%20%0A%20%20FILTER%20%28lang%28%3Fplacename%29%3D%27en%27%29%20%20%0A%7D%20limit%2010000%0A">run query</a> &#x2014; 10000 results in 6253 ms
</p>

<div class="org-src-container">
<pre class="src src-sh">curl -G https://query.wikidata.org/sparql -H <span style="color: #9ccc65;">"Accept: text/tab-separated-values; charset=utf-8"</span> --data-urlencode <span style="color: #ffcc80;">query</span>=<span style="color: #9ccc65;">"</span>
<span style="color: #9ccc65;">SELECT DISTINCT ?placename ?place ?country ?coor ?population where {</span>
<span style="color: #9ccc65;">  ?place wdt:P17 ?country ;</span>
<span style="color: #9ccc65;">         wdt:P625 ?coor ;</span>
<span style="color: #9ccc65;">         wdt:P1082 ?population .</span>
<span style="color: #9ccc65;">  FILTER (?population &gt; 9999)</span>
<span style="color: #9ccc65;">  ?place rdfs:label ?placename .</span>
<span style="color: #9ccc65;">  FILTER (lang(?placename)='en')</span>
<span style="color: #9ccc65;">}</span>
<span style="color: #9ccc65;">"</span>
</pre>
</div>

<p>
Save file as data/wikidata/places.tsv.
</p>
</div>
</div>

<div id="outline-container-orgf569871" class="outline-4">
<h4 id="orgf569871"><span class="section-number-4">3.1.3</span> Fetch all states</h4>
<div class="outline-text-4" id="text-3-1-3">
<p>
This query lists all USA states:
</p>

<div class="org-src-container">
<pre class="src src-sql"><span style="color: #fff59d;">select</span> <span style="color: #fff59d;">DISTINCT</span> ?place ?placename ?country ?coor ?population <span style="color: #fff59d;">where</span> {
  ?place wdt:P17 ?country ;
         wdt:P31 wd:Q35657 ;
         wdt:P625 ?coor ;
         wdt:P1082 ?population .
  ?place rdfs:label ?placename .
  FILTER (lang(?placename)=<span style="color: #9ccc65;">'en'</span>)

}
</pre>
</div>

<p>
List any area that has a capital.
</p>

<div class="org-src-container">
<pre class="src src-sql"><span style="color: #fff59d;">select</span> <span style="color: #fff59d;">DISTINCT</span> ?place ?placename ?country ?coor ?population <span style="color: #fff59d;">where</span> {
  ?place wdt:P17 ?country ;
         wdt:P36 ?capital ;
         wdt:P625 ?coor ;
         wdt:P1082 ?population .
  ?place rdfs:label ?placename .
  FILTER (lang(?placename)=<span style="color: #9ccc65;">'en'</span>)

} <span style="color: #fff59d;">limit</span> 1000
</pre>
</div>

<p>
But I think this is the best option which lists all larger states and
cities that are a member of the subclass 'federal state' or 'region'
</p>

<div class="org-src-container">
<pre class="src src-sql">  <span style="color: #fff59d;">select</span> <span style="color: #fff59d;">distinct</span> ?placename ?place ?country ?population ?coor <span style="color: #fff59d;">where</span> {
  <span style="color: #fff59d;">VALUES</span> ?v { wd:Q82794 wd:Q107390 wd:Q34876 wd:Q9316670 wd:Q515 }
  ?statetype wdt:P279+ ?v .
  ?place wdt:P31 ?statetype ;
         wdt:P17 ?country ;
         wdt:P625 ?coor;
         wdt:P1082 ?population .
  FILTER (?population &gt; 99999)
  ?place rdfs:label ?placename .
  FILTER (lang(?placename)=<span style="color: #9ccc65;">'en'</span>)
}
</pre>
</div>

<p>
The script 'fetch-regions.sh' with curl takes over a minute with about
20K results.
</p>

<p>
Save file as data/wikidata/regions.csv.gz
</p>
</div>
</div>
</div>

<div id="outline-container-org1db088a" class="outline-3">
<h3 id="org1db088a"><span class="section-number-3">3.2</span> Start normalizing geo-location</h3>
<div class="outline-text-3" id="text-3-2">
</div>
<div id="outline-container-orgc02c096" class="outline-4">
<h4 id="orgc02c096"><span class="section-number-4">3.2.1</span> Normalize by country</h4>
<div class="outline-text-4" id="text-3-2-1">
<p>
Now we have three data files from wikidata with place information we
can start normalizing the data we have in the records that are coming
from other sources.
</p>

<p>
The first step is to normalize by country. We take above
country_aliases file which consists of 4 fields
</p>

<pre class="example">
place country countryname alias
</pre>


<p>
and we search "collection_location": "USA: MD" and
"submitter_address": "Maryland Department of Health, 1, 1, MD 1, USA"
fields for matches. That, likely, will get the right country and we
plug in the Wikidata URI, in this case
<a href="http://www.wikidata.org/entity/Q30">http://www.wikidata.org/entity/Q30</a>. If that fails we look for country
aliases from the second wikidata file.
</p>

<p>
"collection_location" gets updated to the new country URI. We also set
the "country" to the same entity at this stage. Arguably that is not
necessary - as the refined location can be queried in wikidata to
provide the country - but we are adding it as a convenience. This also
allows quick visual checks of mismatches in the JSON records.
</p>

<p>
Of course, we immediately hit snags like
"original_collection_location"=&gt;"USA: Utah" -&gt; "country"=&gt;"SA" which
is South Africa instead and it meant we have to add some logic. The logic can
be found in normalize_geo.rb.
</p>
</div>
</div>

<div id="outline-container-org35cadc3" class="outline-4">
<h4 id="org35cadc3"><span class="section-number-4">3.2.2</span> Normalize by state</h4>
</div>

<div id="outline-container-org1c142a5" class="outline-4">
<h4 id="org1c142a5"><span class="section-number-4">3.2.3</span> Refine location</h4>
<div class="outline-text-4" id="text-3-2-3">
<p>
The above step should have normalized country information towards a
wikidata URI. Next we try to refine the location using the places and
regions files downloaded earlier (latest queries are in
<a href="../../workflows/pubseq/wikidata">../../workflows/pubseq/wikidata</a> scripts). They contain for fields for
</p>

<pre class="example">
placename,place,country,coor,population
</pre>


<p>
The current heuristic simply takes all GEO location and resolves by
length of matches. This is not perfect, but works because we only use
places that have a population abvoe 100K. Future refinements should be
by country/state/province/council and distinguish between the
different locations with the same name.
</p>
</div>
</div>
</div>


<div id="outline-container-org56a5937" class="outline-3">
<h3 id="org56a5937"><span class="section-number-3">3.3</span> RegEx search known items</h3>
<div class="outline-text-3" id="text-3-3">
<p>
Hand-filtered search
</p>
</div>
</div>

<div id="outline-container-org8f974fe" class="outline-3">
<h3 id="org8f974fe"><span class="section-number-3">3.4</span> Fuzzy search Wikidata</h3>
<div class="outline-text-3" id="text-3-4">
<p>
You wonder how Wikimedia's search box works?  Wikimedia which powers
Wikipedia and has this amazing `fuzzy' search facility called <a href="https://www.mediawiki.org/wiki/Wikidata_Query_Service/User_Manual/MWAPI">MWAPI</a>
that can be used from Wikidata SPARQL.  The following query finds all
places named Memphis - the <code>wdt:P625</code> forces anything that has map GPS
coordinates(!)
</p>

<div class="org-src-container">
<pre class="src src-sql"><span style="color: #fff59d;">SELECT</span> * <span style="color: #fff59d;">WHERE</span> {
    SERVICE wikibase:mwapi
            { bd:serviceParam wikibase:api "EntitySearch" .
              bd:serviceParam wikibase:endpoint "www.wikidata.org" .
              bd:serviceParam mwapi:<span style="color: #fff59d;">search</span> "memphis" .
              bd:serviceParam mwapi:<span style="color: #fff59d;">language</span> "en" .
              ?place wikibase:apiOutputItem mwapi:item .
              ?num wikibase:apiOrdinal <span style="color: #fff59d;">true</span> .
            }
    ?place wdt:P625 ?coordinates .
  }
</pre>
</div>
<p>
[<a href="https://query.wikidata.org/#SELECT%20%2a%20WHERE%20%7B%0A%20%20SERVICE%20wikibase%3Amwapi%0A%20%20%20%20%20%20%20%20%20%20%7B%20bd%3AserviceParam%20wikibase%3Aapi%20%22EntitySearch%22%20.%0A%20%20%20%20%20%20%20%20%20%20%20%20bd%3AserviceParam%20wikibase%3Aendpoint%20%22www.wikidata.org%22%20.%0A%20%20%20%20%20%20%20%20%20%20%20%20bd%3AserviceParam%20mwapi%3Asearch%20%22memphis%22%20.%20bd%3AserviceParam%20mwapi%3Alanguage%20%22en%22%20.%0A%20%20%20%20%20%20%20%20%20%20%20%3Fitem%20wikibase%3AapiOutputItem%20mwapi%3Aitem%20.%20%3Fnum%20wikibase%3AapiOrdinal%20true%20.%0A%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%3Fitem%20wdt%3AP625%20%3Floc%0A%7D">run query</a>]
</p>

<p>
Above query renders 15 results.
And this lists Memphis uniquely as a city:
</p>

<div class="org-src-container">
<pre class="src src-sql"><span style="color: #fff59d;">SELECT</span> * <span style="color: #fff59d;">WHERE</span> {
  <span style="color: #fff59d;">VALUES</span> ?<span style="color: #fff59d;">type</span> { wd:Q1093829 } .
  SERVICE wikibase:mwapi {
      bd:serviceParam wikibase:api "<span style="color: #fff59d;">Search</span>" .
      bd:serviceParam wikibase:endpoint "www.wikidata.org" .
      bd:serviceParam mwapi:srsearch "memphis te*essee usa" .
      ?place wikibase:apiOutputItem mwapi:title .
  }
  ?place wdt:P625 ?coordinates .
  ?place wdt:P31|wdt:P279 ?<span style="color: #fff59d;">type</span> .
} <span style="color: #fff59d;">limit</span> 10
</pre>
</div>

<p>
But this is the query that is the most flexible as long as the
city/county/country is in there. Note that subclassing should be
possible but I have not figured that out yet:
</p>

<div class="org-src-container">
<pre class="src src-sql"><span style="color: #fff59d;">SELECT</span> * <span style="color: #fff59d;">WHERE</span> {
  # <span style="color: #fff59d;">VALUES</span> ?<span style="color: #fff59d;">type</span> { wd:Q1093829 wd:Q52511956 wd:Q515 wd:Q6256 wd:Q35657} .
  SERVICE wikibase:mwapi {
      bd:serviceParam wikibase:api "<span style="color: #fff59d;">Search</span>" .
      bd:serviceParam wikibase:endpoint "www.wikidata.org" .
      bd:serviceParam mwapi:srsearch "napels italie" .
      ?place wikibase:apiOutputItem mwapi:title .
  }
  ?place wdt:P625 ?coordinates .
  ?place rdfs:label ?placename .
  FILTER( LANG(?placename)="en") .
  ?place wdt:P17 ?country .
  ?place wdt:P1082 ?population .
  # ?place (a|wdt:P31|wdt:P279) ?<span style="color: #fff59d;">type</span> .
}
<span style="color: #fff59d;">ORDER</span> <span style="color: #fff59d;">by</span> <span style="color: #fff59d;">DESC</span>(?population)
<span style="color: #fff59d;">LIMIT</span> 10
</pre>
</div>
<p>
[<a href="https://query.wikidata.org/#SELECT%20%2a%20WHERE%20%7B%0A%20%20%23%20VALUES%20%3Ftype%20%7B%20wd%3AQ1093829%20wd%3AQ52511956%20wd%3AQ515%20wd%3AQ6256%20wd%3AQ35657%7D%20.%0A%20%20SERVICE%20wikibase%3Amwapi%20%7B%0A%20%20%20%20%20%20bd%3AserviceParam%20wikibase%3Aapi%20%22Search%22%20.%0A%20%20%20%20%20%20bd%3AserviceParam%20wikibase%3Aendpoint%20%22www.wikidata.org%22%20.%0A%20%20%20%20%20%20bd%3AserviceParam%20mwapi%3Asrsearch%20%22napels%20italie%22%20.%0A%20%20%20%20%20%20%3Fplace%20wikibase%3AapiOutputItem%20mwapi%3Atitle%20.%0A%20%20%7D%0A%20%20%3Fplace%20wdt%3AP625%20%3Fcoordinates%20.%0A%20%20%3Fplace%20rdfs%3Alabel%20%3Fplacename%20.%0A%20%20FILTER%28%20LANG%28%3Fplacename%29%3D%22en%22%29%20.%0A%20%20%3Fplace%20wdt%3AP17%20%3Fcountry%20.%0A%20%20%3Fplace%20wdt%3AP1082%20%3Fpopulation%20.%0A%20%20%23%20%3Fplace%20%28a%7Cwdt%3AP31%7Cwdt%3AP279%29%20%3Ftype%20.%0A%7D%20%0AORDER%20by%20DESC%28%3Fpopulation%29%20%0ALIMIT%2010">run query</a>]
</p>
</div>
</div>
</div>

<div id="outline-container-org1dd9aaa" class="outline-2">
<h2 id="org1dd9aaa"><span class="section-number-2">4</span> Shape expressions (ShEx) and validation</h2>
<div class="outline-text-2" id="text-4">
<p>
PubSeq uses <a href="http://shex.io/shex-semantics/">ShEx</a> to validate RDF data (see also the <a href="http://shex.io/shex-primer/">primer</a>). This is
particularly useful for data coming from outside. Before data gets
accepted by PubSeq it first needs to go through a ShEx validation
step.
</p>

<p>
<i>To be continued</i>
</p>
</div>
</div>

<div id="outline-container-org99d0c7e" class="outline-2">
<h2 id="org99d0c7e"><span class="section-number-2">5</span> Missing data</h2>
<div class="outline-text-2" id="text-5">
<p>
After normalization, the original data we maintain in a field
`original_collection_location'. If we can normalize to a Wikidata
entry URI that is stored in `collection_location'.  Otherwise it is
missing (RDF favours treating missing data as really missing data).
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<hr><small>Created by <a href="http://thebird.nl/">Pjotr Prins</a> (pjotr.public768 at thebird 'dot' nl) using Emacs org-mode and a healthy dose of Lisp!<br />Modified 2021-04-26 Mon 02:24</small>.
</div>
</body>
</html>
